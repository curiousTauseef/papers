<!DOCTYPE html>
<html>
<head>
  <title>Papers</title>
  <link href='../css/style.css' rel='stylesheet'>
  <meta name=viewport content="width=device-width, initial-scale=1">
</head>

<body>
  <div id=header>
    <a href="../">Papers</a>
  </div>
  <div id="container">
<h1 id="speedy-transactions-in-multicore-in-memory-databases-2013"><a href="https://scholar.google.com/scholar?cluster=1808818331949135820">Speedy Transactions in Multicore In-Memory Databases (2013)</a></h1>
<p><strong>tl;dr</strong> Silo is a relational database that uses Masstrees and a variant of OCC to scale extremely well with the number of available cores by avoiding unnecessary shared-memory contention unless it&#8217;s absolutely necessary.</p>
<p>Computers nowadays have a lot of cores. <a href="https://aws.amazon.com/ec2/instance-types/">AWS</a> and <a href="https://cloud.google.com/compute/docs/machine-types">Google Cloud Platform</a> both offer instances with 96 vCPUs! Unfortunately, having 96x the number of vCPUs often doesn&#8217;t mean that our code will run 96x as fast. Many existing databases don&#8217;t scale well with the number of cores. <strong>Silo</strong> is a single-node main-memory database designed to scale extremely well with the number of cores. It does so using a novel optimistic concurrency control protocol that avoids all shared-memory contention whenever possible. It scales so well, that it can achieve 700,000 transactions per second on a 32-core machine running the TPC-C benchmark! That&#8217;s fast.</p>
<h2 id="data-model-and-storage">Data Model and Storage</h2>
<p>Silo is a fully serializable relational database. Silo only supports one-off transactions: transactions which can be executed completely by the database as soon as they are received, without the need to interact with the client who issued the transaction. Silo stores data in a highly concurrent B+ tree variant, called a Masstree, keyed by a primary key. Secondary indexes, also Masstrees, map secondary attributes to a corresponding set of primary keys (as opposed to record ids). Masstrees have the nice property that reads do not require any shared-memory writes. Masstrees are not inherently versioned, but we&#8217;ll see that Silo will store multiple versions of a record in a Mastree to allow for snapshot transactions.</p>
<h2 id="concurrency-control">Concurrency Control</h2>
<p>Silo assigns each transaction a 64-bit <strong>transaction id</strong>, and this transaction id is stored with every record that the transaction modifies (records also store pointers to previous versions of the same record). However, transaction id is a bit of misnomer. Silo transaction ids are quite a bit more than a simple id. They are divided into three segments:</p>
<ol type="1">
<li>Silo divides time into a sequence of <strong>epochs</strong>. The high-order bits of a transaction id include the epoch in which the transaction committed.</li>
<li>The middle-bits include a monotonically increasing transaction id.</li>
<li>The low-order bits are a status bits indicating whether the record is locked, whether it is tombstoned, and whether it is the latest version of the record.</li>
</ol>
<p>Silo implements a variant of optimistic concurrency control. In the read phase, transactions perform all their reads and buffer all their writes. When a record is read, its transaction id is recorded for later. The validation and write phase proceed as follows:</p>
<pre><code># Sort the write set to prevent deadlock.
for record in sorted(write_set):
    lock(record)

for record, read_tid in read_set:
    if (record.tid != read_tid or
        not record.latest or
        (record.locked and record not in write_set)):
        abort()

commit_tid = generate_commit_tid(read_set, write_set, epoch)

for record, new_value in write_set:
    write(record, new_value, commit_tid)
    unlock(record)</code></pre>
<p>The paper argues that this concurrency control mechanism is correct because it simulates two-phase locking. By checking that every record that was read in the read phase is untouched in the validation phase, it verifies that if we had been running two-phase locking, we could have grabbed and held the read locks in the read phase and held them until the validation phase. I think this a pretty good intuitive explanation, but I&#8217;m guessing a detailed proof of correctness would be quite a bit more complicated.</p>
<p>A thread generates a transaction id such that it&#8217;s guaranteed to be larger than the id of any item in the read or write set and larger than any transaction id previously generated by the thread. Within an epoch, transaction ids don&#8217;t reflect the serial ordering, but across epochs they do.</p>
<h2 id="other-database-bits">Other Database Bits</h2>
<ul>
<li><strong>Reads.</strong> Reads in Silo do not require shared-memory writes. To read a record, a thread reads the record&#8217;s transaction id. Then, it reads the data. Then, it reads the transaction id again. If the transaction id did not change, then the record is valid. If it did change, then the thread loops and tries again.</li>
<li><strong>Deletes.</strong> To enable snapshot reads, items are tombstoned in Silo instead of deleted. Tombstoned data is eventually cleaned up using garbage collection.</li>
<li><strong>Inserts.</strong> Silo&#8217;s concurrency control protocol acquires locks on modified objects, so it must insert an object first and then get a lock on it, being careful that two transactions do not simultaneously insert a tuple with the same primary key.</li>
<li><strong>Range queries and phantoms.</strong> Masstree nodes are timestamped much like records. In addition to recording a read and write set, threads also record a node set: the set of the nodes and node timestamps read during a range query. During validation, a thread checks that the node timestamps have not changed.</li>
<li><strong>Garbage collection.</strong> Data from old epochs are periodically deleted by the threads.</li>
<li><strong>Snapshot transactions.</strong> Transactions can read old versions in the Mastree for snapshot transactions.</li>
<li><strong>Durability.</strong> Silo persists transactions one epoch at a time, not returning to the client until the end of the epoch. Only committed transactions are persisted, so only redo information is needed.</li>
</ul>
  </div>

  <script type="text/javascript" src="../js/mathjax_config.js"></script>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-90310997-2', 'auto');
		ga('send', 'pageview');
	</script>
</body>
</html>
