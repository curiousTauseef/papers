<!DOCTYPE html>
<html>
<head>
  <title>Papers</title>
  <link href='../css/style.css' rel='stylesheet'>
  <meta name=viewport content="width=device-width, initial-scale=1">
</head>

<body>
  <div id=header>
    <a href="../">Papers</a>
  </div>
  <div id="container">
<h2 id="dryadlinq-a-system-for-general-purpose-distributed-data-parallel-computing-using-a-high-level-language-2008"><a href="#dryadlinq-a-system-for-general-purpose-distributed-data-parallel-computing-using-a-high-level-language-2008">DryadLINQ: A System for General-Purpose Distributed Data-Parallel Computing Using a High-Level Language (2008)</a></h2>
<p>DryadLINQ is a language extension and system which allows users to write data-parallel code in a high-level language (i.e. LINQ supported languages like C#, VB, F#, etc.) that operates over typed .NET objects. The code is then automatically and transparently distributed by translating it to an optimized Dryad job. MapReduce</p>
<ul>
<li>doesn't really have a type system;</li>
<li>forces users to express complex programs as multiple MapReduce jobs; and</li>
<li>doesn't support interstage optimizations.</li>
</ul>
<p>Relation databases</p>
<ul>
<li>have very primitive type systems; and</li>
<li>SQL is hard to use to express complex iterative workloads.</li>
</ul>
<p>DryadLINQ doesn't suffer from these disadvantages.</p>
<p><strong>System Architecture.</strong> DryadLINQ compiles LINQ programs to Dryad jobs. To review, Dryad represents computation as a graph where vertexes run C++ code and edges transport messages between vertexes using temporary files, TCP connections, or in-memory pipes. Dryad</p>
<ol style="list-style-type: decimal">
<li>instantiates dataflow graphs;</li>
<li>schedules tasks on workers;</li>
<li>handles faults by re-running failed vertexes;</li>
<li>monitors the progress of a job and exports it to users; and</li>
<li>facilitates runtime graph optimizations.</li>
</ol>
<p>DryadLINQ execution follows the following the steps:</p>
<ol style="list-style-type: decimal">
<li>.NET programs lazily generate a DryadLINQ expression.</li>
<li>The program calls <code>ToDryadTable</code> which forces the execution of the expression.</li>
<li>The system compiles the expression into a Dryad graph.</li>
<li>A Job Manager (JM) is launched.</li>
<li>The JM spawns workers on the cluster.</li>
<li>Workers execute vertexes.</li>
<li>When the Dryad job finishes, the output is written into a table.</li>
<li>A <code>DryadTable</code> object is created.</li>
<li>Control is returned to the user.</li>
<li>Repeat.</li>
</ol>
<p><strong>Programming with DryadLINQ.</strong></p>
<p><em>LINQ.</em> Users write programs using LINQ. The base type in LINQ is <code>IEnumerable&lt;T&gt;</code> which represents an arbitrary iterable collection. There is also an <code>IQueryable&lt;T&gt;</code> subclass of <code>IEnumerable&lt;T&gt;</code> which represents an unevaluated LINQ expression which produces an <code>IEnumerable&lt;T&gt;</code>. <code>IQueryable</code>s are computed lazily. LINQ supports a SQL-like declarative interface as well as a more imperative object-oriented style.</p>
<p><em>DryadLINQ.</em> DryadLINQ adds a couple features and restrictions to LINQ. DryadLINQ datasets are stored in <code>DryadTable&lt;T&gt;</code>s: a distributed collection partitioned across a number of machines. A <code>DryadTable</code> is a subtype of <code>IQueryable</code> and can be stored in a distributed file system, a relational database, etc. Input and output <code>DryadTable</code>s are generated by calling <code>GetTable</code> and <code>ToDryadTable</code>. DryadLINQ adds new operators to partition data. It also provides two escape hatch operators: <code>Apply</code> and <code>Fork</code>. <code>Apply</code> calls arbitrary code with an iterator over a <code>DryadTable</code>. <code>Fork</code> calls arbitrary code which generates multiple different outputs. In the worst case, a <code>Fork</code> or <code>Apply</code> is executed at a single node. DryadLINQ also allows users to specify optimization hints to the compiler.</p>
<p><em>Building on DryadLINQ.</em> It's easy to build even higher level interfaces on top of DryadLINQ. For example, it's easy to build MapReduce and ML libraries on top of DryadLINQ.</p>
<p><strong>System Implementation.</strong></p>
<p><em>Execution Plan Graph.</em> DryadLINQ converts LINQ expressions into Execution Plan Graphs (EPG) which are like query plans in a traditional relational database query optimizer. The EPG is optimized and acts as a skeleton for the final Dryad graph it is converted to. Vertexes of the EPG are annotated with type information and the edges are annotated with partitioning and ordering information.</p>
<p><em>Static Optimizations.</em> - <em>Pipelining.</em> If multiple vertexes are chained directly together, Dryad can run them in a single process. - <em>Removing Redundancy.</em> DryadLINQ tries to avoid unnecessary or redundant partitions since they are expensive. - <em>Eager Aggregation.</em> If an aggregation can be pushed before a partitioning, it is. - <em>I/O Reduction.</em> DryadLINQ tries to make all edges TCP pipes or in-memory pipes. It also compresses data before a partition.</p>
<p><em>Dynamic Optimizations.</em> DryadLINQ performs tree aggregation, but the structure of the tree depends on scheduling decisions that are made at runtime. It also can dynamically determine the number of partitions or how a dataset is partitioned at runtime based on the size of the dataset. Traditional databases would often have to estimate this information and could be wildly wrong.</p>
<p><em>Code Generation.</em> When an EPG is converted into a Dryad graph, code is generated to (a) process data on vertexes and (b) serialize and deserialize data. Also, any values that the LINQ programs reference have to be serialized and shipped with the code. Any libraries the code depends on also have to be shipped.</p>
<p><em>Leveraging Other LINQ Providers.</em> PLINQ is a system which runs LINQ programs in parallel on a single multicore machine. DryadLINQ uses PLINQ within a vertex. It also uses a LINQ-to-SQL converter which allows vertexes to run SQL queries constructed from LINQ expressions.</p>
<p><em>Debugging.</em> DryadLINQ's typechecking helps catch a lot of bugs. An entire cluster can also be run on a user's local machine to debug the execution of the program. If a node fails while running, the system can also re-run the node to see what the problem is. Performance debugging is doable but still challenging.</p>
  </div>

  <script type="text/javascript" src="../js/mathjax_config.js"></script>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-90310997-2', 'auto');
		ga('send', 'pageview');
	</script>
</body>
</html>
