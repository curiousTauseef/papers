<!DOCTYPE html>
<html>
<head>
  <title>Papers</title>
  <link href='../css/style.css' rel='stylesheet'>
  <meta name=viewport content="width=device-width, initial-scale=1">
</head>

<body>
  <div id=header>
    <a href="../">Papers</a>
  </div>
  <div id="container">
<h1 id="scheduling-algorithms-for-multiprogramming-in-a-hard-real-time-environment-1973"><a href="https://scholar.google.com/scholar?cluster=11972780054098474552&amp;hl=en&amp;as_sdt=0,5">Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment (1973)</a></h1>
<p>Consider a hard-real-time environment in which tasks <em>must</em> finish within some time after they are requested. We make the following assumptions.</p>
<ul>
<li>(A1) Tasks are periodic with fixed periods.</li>
<li>(A2) Tasks must finish before they are next requested.</li>
<li>(A3) Tasks are independent.</li>
<li>(A4) Tasks have constant runtime.</li>
<li>(A5) Non-periodic tasks are not realtime.</li>
</ul>
<p>Thus, we can model each task $t_i$ as a period $T_i$ and runtime $C_i$. A scheduling algorithm that immediately preempts tasks to guarantee that the task with the highest priority is running is called a <strong>preemptive priority scheduling algorithm</strong>. We consider three preemptive priority scheduling algorithms: a static/fixed priority scheduler (in which priorities are assigned ahead of time), a dynamic priority scheduler (in which priorities are assigned at runtime), and a mixed scheduling algorithm.</p>
<h2 id="fixed-priority-scheduling-algorithm">Fixed Priority Scheduling Algorithm</h2>
<p>First, a few definitions:</p>
<ul>
<li>The <strong>deadline</strong> of a task is the time at which the next request is issued.</li>
<li>An <strong>overflow</strong> occurs at time $t$ if $t$ is the deadline for an unfulfilled task.</li>
<li>A schedule is <strong>feasible</strong> if there is no overflow.</li>
<li>The response time of a task is the time between the task's request and the task's finish time.</li>
<li>A <strong>critical instant</strong> for task $t$ is the instant where $t$ has the highest response time.</li>
</ul>
<p>It can be shown that the critical instant for any task occurs when the task is requested simultaneously with all higher priority tasks. This result lets us easily determine if a feasible fixed priority schedule exists by pessimistically assuming all tasks are scheduled at their critical instant.</p>
<p>It also suggests that given two tasks with periodicities $T_1$ and $T_2$ where $T_1 &lt; T_2$, we should give higher priority to the shorter task with period $T_1$. This leads to the <strong>rate-monotonic priority scheduling algorithm</strong> where we assign higher priorities to shorter tasks. A feasible static schedule exists if and only if a feasible rate-monotonic scheduling algorithm exists.</p>
<p>Define <strong>processor utilization</strong> to be the fraction of time the processor spends running tasks. We say a set of tasks <strong>fully utilize</strong> the processor if there exists a feasible schedule for them, but increasing the running time of any of the tasks implies there is no feasible schedule. The least upper bound on processor utilization is the minimum processor utilization for tasks that fully utilize the processor. For $m$ tasks, the least upper bound is $m(2^{1/m} - 1)$ which approaches $\ln(2)$ for large $m$.</p>
<h2 id="deadline-driven-scheduling-algorithm">Deadline Driven Scheduling Algorithm</h2>
<p>The <strong>deadline driven scheduling algorithm</strong> (or earliest deadline first scheduling algorithm) dynamically assigns the highest priority to the task with the most imminent deadline. This scheduling algorithm has a least upper bound of 100% processor utilization. Moreover, if any feasible schedule exists for a set of tasks, a feasible deadline driven schedule exists.</p>
<h2 id="mixed-scheduling-algorithm.">Mixed Scheduling Algorithm.</h2>
<p>Scheduling hardware (at the time) resembled a fixed priority scheduler, but a dynamic scheduler could be implemented for less frequent tasks. A hybrid scheduling algorithm scheduled the $k$ most frequent tasks using the rate-monotonic scheduling algorithm and scheduled the rest using the deadline driven algorithm.</p>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  </div>

  <script type="text/javascript" src="../js/mathjax_config.js"></script>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-90310997-2', 'auto');
		ga('send', 'pageview');
	</script>
</body>
</html>
